[{"categories":null,"content":"npm仓库信息 npm: https://www.npmjs.com/package/uuid downloads: 460w git: github.com/uuidjs/uuid#readme repo: 12k ","date":"2021-10-19","objectID":"/2021/10/19/20211019_uuid/:1:0","tags":null,"title":"UUID到底是什么？npm分享之uuid","uri":"/2021/10/19/20211019_uuid/"},{"categories":null,"content":"UUID分析 UUID(Universally unique identifier)，统一资源定位符，可以用来标识唯一的资源。典型的UUID长这个样子。 123e4567-e89b-12d3-a456-426614174000 xxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx 你可能经常使用，但是大概率很难讲个所以然。实际上，目前我们使用的UUID，主要遵循RFC4122版本，协议的链接在 https://www.ietf.org/rfc/rfc4122.txt 。协议的本身有很多个版本，比如v1，v2，v3，v4，v5。版本不同是因为其使用的工况可能不同，官方的定义如下: Msb0 Msb1 Msb2 Msb3 Version Description 0 0 0 1 1 The time-based version specified in this document. 0 0 1 0 2 DCE Security version, with embedded POSIX UIDs. 0 0 1 1 3 The name-based version specified in this document that uses MD5 hashing. 0 1 0 0 4 The randomly or pseudo- randomly generated version specified in this document. 0 1 0 1 5 The name-based version specified in this document that uses SHA-1 hashing. 版本多的让人眼花缭乱，那么实际上在使用的时候改用哪种呢？参考StackOverflow的高票答案，可以按照这个方法选择 仅需要一个UUID: 可以使用version1 和 version4 version1: 基于网卡mac地址+时间戳构建。 version4: 完全基于随机数/伪随机数构建。 UUID需要基于一定的参数可重建(reproducible)，需要version3或者version5 version3: 基于namespace+name → MD5 version5: 基于namespace+name → SHA-1 基于以上的原则，就可以容易的选择版本。其中有个细节可以注意的是，由于v4版本完全基于时间戳构建，所以理论上可能存在UUID碰撞的可能。但是实际在使用中不用太在意，有两个原因: 1. 碰撞的几率天生就很小; 2. 碰撞几率计算也是根据所有场景放在一起，但是每个应用都有自己的场景，uuid也不会通用，因此实际上不用担心。 当然，如果只是使用uuidv4的话，可以使用这个代码片段 (https://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid) function uuidv4() { return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =\u003e (c ^ crypto.getRandomValues(new Uint8Array(1))[0] \u0026 15 \u003e\u003e c / 4).toString(16) ); } console.log(uuidv4()); ","date":"2021-10-19","objectID":"/2021/10/19/20211019_uuid/:2:0","tags":null,"title":"UUID到底是什么？npm分享之uuid","uri":"/2021/10/19/20211019_uuid/"},{"categories":null,"content":"使用 import { v1 as uuidv1 } from 'uuid'; uuidv1(); // ⇨ '2c5ea4c0-4067-11e9-8bad-9b1deb4d3b7d' 使用起来比较简单，不在赘述。 ","date":"2021-10-19","objectID":"/2021/10/19/20211019_uuid/:3:0","tags":null,"title":"UUID到底是什么？npm分享之uuid","uri":"/2021/10/19/20211019_uuid/"},{"categories":null,"content":"What’more 无三方库。 ","date":"2021-10-19","objectID":"/2021/10/19/20211019_uuid/:4:0","tags":null,"title":"UUID到底是什么？npm分享之uuid","uri":"/2021/10/19/20211019_uuid/"},{"categories":null,"content":"URL的参数你真的懂吗？-querystring https://example.com/path/to/page?name=ferret\u0026color=purple 大家都熟悉，querystring是URL的参数传递方式。上面就是他的数据格式。 但是如果要问问你querystring到底来自哪个标准？具体的处理方式你真的懂吗？可能大部分人都要摇头。这篇文章就能帮到你。 ","date":"2021-10-19","objectID":"/2021/10/19/20211018_querystring/:0:0","tags":null,"title":"URL的参数你真的懂吗？-querystring","uri":"/2021/10/19/20211018_querystring/"},{"categories":null,"content":"背景 querystring主要来自URL标准，URL全称为Uniform Resource Locators，统一资源定位符。Web是其最常见的使用场景，除此之外，ftp、ssh等协议也是基于这些标准来使用的，举个例子。 # Web URL https://example.com/path/to/page?name=ferret\u0026color=purple # Ftp URL ftp://test:test@192.168.0.1:21/profile URL是一个标准，主要有两个版本: rfc1738: https://datatracker.ietf.org/doc/html/rfc1738 rfc3986: https://datatracker.ietf.org/doc/html/rfc3986 querystring就来自这个URL标准，querystring主要处理两部分: 数据传输格式: paramA=valueA\u0026paramB=valueB 数据的编码解码: 1)预留字符 # : 2) 特殊字符转码 SPACE -\u003e 0x20 qs库呢，就是这两部分逻辑的具体实现。那么刚刚提到了rfc1738和rfc3986，在querystring方便主要是对 SPACE %20 的处理方式不同，rfc1738 %20-\u003e +, rfc3986保留 %20 数据传输格式 field1=value1\u0026field2=value2\u0026field3=value3... 当然可能有的场景也会传输一些特殊的字符，比如JSON、数组等等，但是一般大家在使用过程中，都会先encode，变成普通的字符串；解码的时候再进行反向操作。 数据的编码解码 我们不去读常常的RFC标准了，在Wiki上可以找到如下的编解码定义: Characters that cannot be converted to the correct charset are replaced with HTML numeric character references[11] SPACE is encoded as ‘+’ or ‘%20’ Letters (A–Z and a–z), numbers (0–9) and the characters ‘~’,'-','.' and ‘_’ are left as-is is encoded by %2B All other characters are encoded as a %HH hexadecimal representation with any non-ASCII characters first encoded as UTF-8 (or other specified encoding) 用大白话呢就是下面这个，注意步骤2中关于SPACE空格的处理，就是两个不同协议的区别。 如果某个字符编码不能转成对应的字符，那么就使用数字的替代表示(数学字符等) 空白SPACE，转成 + 或者 %20 ( + 的ASCII编码为 0x20) A-z a-z 0-9 ~ - . _ 这些字符保留 转为 %2B 其他剩余字符，转为%HH的十六进制表示 ","date":"2021-10-19","objectID":"/2021/10/19/20211018_querystring/:1:0","tags":null,"title":"URL的参数你真的懂吗？-querystring","uri":"/2021/10/19/20211018_querystring/"},{"categories":null,"content":"qs 回到qs这个依赖库，就是对上述操作进行了封装。当然qs本身在对象数据的传输、解析(深度控制等)、数组等做了很多工作，但是实际上用的都比较少。 使用 举个官方的例子 var qs = require('qs'); var assert = require('assert'); var obj = qs.parse('a=c'); assert.deepEqual(obj, { a: 'c' }); var str = qs.stringify(obj); assert.equal(str, 'a=c'); What’s More 在面向IE等老破浏览器编程的时候，其实这种库是特别有价值的，但是现代浏览器和Node都提供了相似的内置API，可以直接使用 Web: https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams Node: https://nodejs.org/api/url.html#url_class_urlsearchparams ","date":"2021-10-19","objectID":"/2021/10/19/20211018_querystring/:1:1","tags":null,"title":"URL的参数你真的懂吗？-querystring","uri":"/2021/10/19/20211018_querystring/"},{"categories":null,"content":"今天和大家聊聊两个常用的库 lodash.get https://www.npmjs.com/package/lodash.get Idx https://www.npmjs.com/package/idx ","date":"2021-10-18","objectID":"/2021/10/18/20211018_npm_idx_lodash/:0:0","tags":null,"title":"防御式编程利器: lodash.get 和 idx","uri":"/2021/10/18/20211018_npm_idx_lodash/"},{"categories":null,"content":"Can not read property of undefined 取不到应该有的值，是开发中常见的情况，大部分语言都有这个问题，C语言会变成野指针；Java会有NullPointerException；同样的在JavaScript中就是undefined。在和其他三方库或者服务端交互的时候，这种情况经常出现。一旦出现，就很糟心，会阻塞代码执行；会抛出异常；甚至会引起白屏等渲染异常。 图片 为了避免我们的代码挂掉，我们常常会采用防御式编程。当然这是文绉绉的说法，简单来说，就是一路判断下去，比如: variables \u0026\u0026 variable.propertyA \u0026\u0026 variable.propertyA.propertyB. 数据结构简单的情况下，这样写挺好；可是如果层数特别多，又或是有数组，情况就变得难受起来，举个例子: variables \u0026\u0026 variable.propertyA \u0026\u0026 variable.propertyA.propertyB \u0026\u0026 variable.propertyA.propertyB[0] \u0026\u0026 variable.propertyA.propertyB[0].propertyC ","date":"2021-10-18","objectID":"/2021/10/18/20211018_npm_idx_lodash/:1:0","tags":null,"title":"防御式编程利器: lodash.get 和 idx","uri":"/2021/10/18/20211018_npm_idx_lodash/"},{"categories":null,"content":"怎么省事？ lodash.get和idx这两个库都可以帮我们面对这种情况，先看lodash.get. lodash.get实际上是lodash工具库的一个子集。这是一些官方的例子。 var object = { 'a': [{ 'b': { 'c': 3 } }] }; _.get(object, 'a[0].b.c'); // =\u003e 3 _.get(object, ['a', '0', 'b', 'c']); // =\u003e 3 _.get(object, 'a.b.c', 'default'); // =\u003e 'default' _.get(object, path, [defaultValue]) 有3个变量， 为被索引的对象object 为访问属性的路径path 为默认数值defaultValue。 其中关键的参数为path。举个例子，如果path为a[0].b.c，则表示a为数组，a的第一个元素，并进一步获取该其下的属性b，属性b下的属性c。那么我们把前面的例子用lodash.get重新写一遍，怎么写呢？ // pure javascript variables \u0026\u0026 variable.propertyA \u0026\u0026 variable.propertyA.propertyB \u0026\u0026 variable.propertyA.propertyB[0] \u0026\u0026 variable.propertyA.propertyB[0].propertyC // lodash.get _.get(variables, ‘propertyA.propertyB[0].propertyC’) 简单明了。同样的，idx的作用是一样。 // idx idx(variables, _ =\u003e _.propertyA.propertyB[0].propertyC) 哪个更好呢？从下载量上看，lodash.get的使用人数会更多，但是两者功能是同样的，性能也没大差别，看个人的喜好即可。 ","date":"2021-10-18","objectID":"/2021/10/18/20211018_npm_idx_lodash/:2:0","tags":null,"title":"防御式编程利器: lodash.get 和 idx","uri":"/2021/10/18/20211018_npm_idx_lodash/"}]
[{"categories":["npm源码剖析"],"content":"validator 字符串判断神器 ","date":"2021-11-14","objectID":"/2021/11/14/20211114_validator/:0:0","tags":["npm源码剖析","string","validator"],"title":"npm源码剖析系列-validator 字符串判断神器","uri":"/2021/11/14/20211114_validator/"},{"categories":["npm源码剖析"],"content":"一句话概括 我们经常需要判断一个字符串，是不是符合某种业务规则。比如是否是E-mail? 电话？信用卡？等等。很多情况下，我们会手写正则去判断，但是实际上经常会遗漏各种边界条件。 validator就可以帮我们解决这种问题。内置了几十种的判断方法，简单列几个，可以按需索取。 isAfter isAlpha isAscii isBase64 isDate … ","date":"2021-11-14","objectID":"/2021/11/14/20211114_validator/:1:0","tags":["npm源码剖析","string","validator"],"title":"npm源码剖析系列-validator 字符串判断神器","uri":"/2021/11/14/20211114_validator/"},{"categories":["npm源码剖析"],"content":"安装和使用 安装 npm i validator 使用 var validator = require('validator'); validator.isEmail('foo@bar.com'); //=\u003e true ","date":"2021-11-14","objectID":"/2021/11/14/20211114_validator/:2:0","tags":["npm源码剖析","string","validator"],"title":"npm源码剖析系列-validator 字符串判断神器","uri":"/2021/11/14/20211114_validator/"},{"categories":["npm源码剖析"],"content":"源码简析 validator，就是对字符串进行一系列的规则校验。根据每个业务场景的不一样，所以每个规则的校验方法也不同。其中呢，大部分是通过正则表达式的校验，因此在其中有些判断逻辑，甚至是正则表达式我们可以好好收藏一下。 ","date":"2021-11-14","objectID":"/2021/11/14/20211114_validator/:3:0","tags":["npm源码剖析","string","validator"],"title":"npm源码剖析系列-validator 字符串判断神器","uri":"/2021/11/14/20211114_validator/"},{"categories":["npm源码剖析"],"content":"判断是字符串 一般情况下，判断字符串只要看看是不是string就可以了，如果要做的完美一些了，还要看看是不是String的对象。 typeof new String() === 'object' export default function assertString(input) { const isString = typeof input === 'string' || input instanceof String; if (!isString) { let invalidType = typeof input; if (input === null) invalidType = 'null'; else if (invalidType === 'object') invalidType = input.constructor.name; throw new TypeError(`Expected a string but received a ${invalidType}`); } } ","date":"2021-11-14","objectID":"/2021/11/14/20211114_validator/:3:1","tags":["npm源码剖析","string","validator"],"title":"npm源码剖析系列-validator 字符串判断神器","uri":"/2021/11/14/20211114_validator/"},{"categories":["npm源码剖析"],"content":"判断是否为Boolean 看到这个问题，你可能和我一样吃惊，但是当你真的遇到各种情况下boolean的实际值，更会惊吓下巴。 const defaultOptions = { loose: false }; const strictBooleans = ['true', 'false', '1', '0']; const looseBooleans = [...strictBooleans, 'yes', 'no']; export default function isBoolean(str, options = defaultOptions) { assertString(str); if (options.loose) { return looseBooleans.includes(str.toLowerCase()); } return strictBooleans.includes(str); } 可以注意的是，很多时候 1和 true都代表了布尔值 true ，同样的 0和 false都代表了布尔值 false ，尤其在序列化反序列化的场景下，经常会遇到。 ","date":"2021-11-14","objectID":"/2021/11/14/20211114_validator/:3:2","tags":["npm源码剖析","string","validator"],"title":"npm源码剖析系列-validator 字符串判断神器","uri":"/2021/11/14/20211114_validator/"},{"categories":["npm源码剖析"],"content":"常用的API https://github.com/validatorjs/validator.js ","date":"2021-11-14","objectID":"/2021/11/14/20211114_validator/:4:0","tags":["npm源码剖析","string","validator"],"title":"npm源码剖析系列-validator 字符串判断神器","uri":"/2021/11/14/20211114_validator/"},{"categories":["npm源码剖析"],"content":"npm源码剖析系列-Schema校验神器之Yup ","date":"2021-10-22","objectID":"/2021/10/22/20211022_yup/:0:0","tags":["npm源码剖析","yup","schema","validator"],"title":"npm源码剖析系列-Schema校验神器之Yup","uri":"/2021/10/22/20211022_yup/"},{"categories":["npm源码剖析"],"content":"一句话概括 yup是一个schema校验工具库。 前端用户表单的时候，我们经验需要在前后端校验用户的输入。一般而言，因为我们预先知道每个字段的含义，所以可以通过预先针对每一个字段执行条件语句判断是否合法。 但是随着表单字段的增多，结构的复杂，校验规则就会变得复杂起来。如果遇到嵌套数组等情况，校验工作会变得更加复杂棘手。 此外，如果我们的校验逻辑和业务逻辑耦合在一起，当校验规则需要调整的时候，需要进行大量的修改和回归操作。 因此，将校验工作抽离为单独的组件，并且支持灵活的配置规则，就变得特别重要。那yup的出现，就在于解决这些问题。 yup的使用非常简单，举个例子: let schema = yup.object().shape({ name: yup.string().required(), age: yup.number().required().positive().integer(), email: yup.string().email(), website: yup.string().url(), createdOn: yup.date().default(function () { return new Date(); }), }); const validated = schema.validateSync({ name: 'Hulk', age: 18, }); 上述schema就是一个对用户信息的校验逻辑，非常已于读取，可以很容易了解到各个字段的含义: name: 字符串，必须 age: 数字、必须、整形、正数 email: E-mail类型、可选 website: Url类型、类型 createdOn: 日期类型、可选、支持配置默认 当然实际上，yup支持的逻辑要复杂的多，具体在源码中详细分析。实际上还有一个非常常用好用的手段，可以基于yup，添加自己的校验逻辑，输出一个业务特色的字段校验库。 ","date":"2021-10-22","objectID":"/2021/10/22/20211022_yup/:1:0","tags":["npm源码剖析","yup","schema","validator"],"title":"npm源码剖析系列-Schema校验神器之Yup","uri":"/2021/10/22/20211022_yup/"},{"categories":["npm源码剖析"],"content":"源码简析 相比之前的总结，Yup的源码变得复杂起来。从功能入手，Yup就是对用户输入进行Schema的校验。其核心代码也聚焦在这两个部分。 两部分分别是: 构建/编译Schema 和 校验Schema。 构建 是我们定义Schema格式的过程，参考我们文章开头的测试代码: let schema = yup.object().shape({ name: yup.string().required(), age: yup.number().required().positive().integer(), email: yup.string().email(), website: yup.string().url(), createdOn: yup.date().default(function () { return new Date(); }), }); 在上述代码中，我们定义一个用户信息的Schema校验规则。我们可以注意到这么几个细节: yup的校验是支持对象，也支持简单的变量 yup的校验，支持可选和必选 yup内置了一些数字、字符串、日期等常见的校验格式，对于字符串等内置了常见的email、url等校验规则。 yup的schema构建，是支持 链式调用 的。 那么校验的过程呢，对比我们的测试代码: const validated = schema.validateSync({ name: 'Hulk', age: 18, }); 因此对于校验的过程，validateSync是我们的核心切入点。在这里呢，我整理了一份整体的源码框架示意图，可以和大家一块，抓大放小的整理清楚。 ","date":"2021-10-22","objectID":"/2021/10/22/20211022_yup/:2:0","tags":["npm源码剖析","yup","schema","validator"],"title":"npm源码剖析系列-Schema校验神器之Yup","uri":"/2021/10/22/20211022_yup/"},{"categories":["npm源码剖析"],"content":"整体流程 读懂了这张图，就能搞清楚Yup的核心思想。通过这个图，我们可以得出以下几个结论。 Yup的核心功能，均是通过Schema模块导出。而Schema也就是我们前面提到的构建Schema、校验Schema的基础，其物理含义则代表了一系列的规则。 Yup内置了一些常用的Schema，比如数字、字符串、对象、数组等等，足以覆盖我们常见的场景。 resolve和validate是其中比较重要的方法。 那么我们展开来看下。 ","date":"2021-10-22","objectID":"/2021/10/22/20211022_yup/:2:1","tags":["npm源码剖析","yup","schema","validator"],"title":"npm源码剖析系列-Schema校验神器之Yup","uri":"/2021/10/22/20211022_yup/"},{"categories":["npm源码剖析"],"content":"构建Schema 规则的存储 Yup源码中，类Schema作为规则的核心承载，其源码在src/schema.ts。本小节我们主要看如何构建Schema。直接分析最复杂之一的 object 规则。 // 创建Object规则 let schema = yup.object().shape({ name: yup.string().required(), age: yup.number().required().positive().integer(), }); 创建规则对象 Yup中内置了很对规则，通过 object、 string 、 number 等符号导出。导出的为一个构造方法，也就是当我们调用 object 的时候，本质上调用 ObjectCrate方法，并创建了一个对应的 ObjectSchema对象。相关代码如下 // src/index.ts export { mixedCreate as mixed, objectCreate as object, // 导出object方法 }; // src/object.ts export function create\u003cTShape extends ObjectShape\u003e(spec?: TShape) { return new ObjectSchema\u003cTShape\u003e(spec) as OptionalObjectSchema\u003cTShape\u003e; } 校验validate validate 是校验的主入口，这块代码有些复杂，我们先看父类 BaseSchema 的定义 protected _validate( _value: any, options: InternalOptions\u003cTContext\u003e = {}, cb: Callback, ): void { let value = _value; if (!strict) { // this._validating = true; value = this._cast(value, { assert: false, ...options }); // this._validating = false; } let initialTests = []; if (this._typeError) initialTests.push(this._typeError); let finalTests: any[] = []; if (this._whitelistError) finalTests.push(this._whitelistError); if (this._blacklistError) finalTests.push(this._blacklistError); runTests( { args, value, path, sync, tests: initialTests, endEarly: abortEarly, }, (err) =\u003e { if (err) return void cb(err, value); runTests( { tests: this.tests.concat(finalTests), args, path, sync, value, endEarly: abortEarly, }, cb, ); }, ); } 看着似懂非懂，其实整体上可以分为以下3步: 整理数据，比如上述就整理了 initialTests 、 finalTests 调用runTests，先验证 initialTest 规则是否满足；如果不满足，直接error callback. 构建新的tests集合， tests = this.tests.concat(finalTest) ，然后重复步骤2 可以看出来，关键有两个元素，一个是测试集合 tests，另一个是 runTest 方法。 runTest 方法比较简单，不在赘述，重点看下 tests 测试集合如何生成。 通过 BaseSchema 代码可知， test为一个数组，当某个具体的Type在定义某些边界约束的时候，会操作 test 变量，具体 boolean 类型的例子 isTrue( message = locale.isValue, ): BooleanSchema\u003cTType | true, TContext, true | Optionals\u003cTOut\u003e\u003e { return this.test({ message, name: 'is-value', exclusive: true, params: { value: 'true' }, test(value) { return isAbsent(value) || value === true; }, }) as any; } 观察上述代码，我们可以通过 yup.bool().isTrue() 来引用。我们可以看到，其调用了 BaseSchema 的 test 方法，相关一些关键的实现如下 test(...args: any[]) { if (typeof opts.test !== 'function') throw new TypeError('`test` is a required parameters'); let next = this.clone(); let validate = createValidation(opts); next.tests = next.tests.filter((fn) =\u003e { if (fn.OPTIONS.name === opts.name) { if (isExclusive) return false; if (fn.OPTIONS.test === validate.OPTIONS.test) return false; } return true; }); next.tests.push(validate); return next; } 这下就清楚了，当子类调用 this.test 方法的时候，会重新构建整个test链： clone一份当前的test集合 遍历test数组，重新生成可以调用的test序列 将入参新的test测试方法放入队尾 返回整个test数组 小结 至此，已经将关键的节点链路分析完毕，有些松散，也有些凌乱，我们重新梳理一遍。通过代码可以得知，yup在处理的时候，可以分为两类: 基本类型，比如 boolean array number string 等，这些校验比较简单，基本上是在类型判断的基础之上，添加一些边界的约束 Object/Mix等复杂类型，基本上顺延基类的思路，但是关键的 validate 等方法都重新进行了设计。 ","date":"2021-10-22","objectID":"/2021/10/22/20211022_yup/:2:2","tags":["npm源码剖析","yup","schema","validator"],"title":"npm源码剖析系列-Schema校验神器之Yup","uri":"/2021/10/22/20211022_yup/"},{"categories":["npm源码剖析"],"content":"如何使用 ","date":"2021-10-22","objectID":"/2021/10/22/20211022_yup/:3:0","tags":["npm源码剖析","yup","schema","validator"],"title":"npm源码剖析系列-Schema校验神器之Yup","uri":"/2021/10/22/20211022_yup/"},{"categories":["npm源码剖析"],"content":"依赖其他字段不同 const yup = require('yup'); let personSchema = yup.object({ name: yup.string().min(4), gender: yup.string(), id: yup.string().when('gender', { is: 'F', then: s =\u003e s.matches(/F.*/g), otherwise: s =\u003e s.matches(/M.*/g) }) }); console.log(personSchema.isValidSync({ name: 'Lucy', gender: 'F', id: 'F123', })); // true console.log(personSchema.isValidSync({ name: 'Lucy', gender: 'F', id: 'M123', })); // false console.log(personSchema.isValidSync({ name: 'John', gender: 'M', id: 'M123', })); // true 如上，我们定义了一个PersonSchema的校验规则，其中需要注意的是Id，通过when方法，根据gender性别的不同，定义了两种前缀。如果为女性F，那么要求id以F开头，如果为男性M，则要求id以M开头。 ","date":"2021-10-22","objectID":"/2021/10/22/20211022_yup/:3:1","tags":["npm源码剖析","yup","schema","validator"],"title":"npm源码剖析系列-Schema校验神器之Yup","uri":"/2021/10/22/20211022_yup/"},{"categories":["npm源码剖析"],"content":"自定义String类型的判断规则 方法1: 通过正则匹配 let personSchema = yup.object({ name: yup.string().min(4), gender: yup.string().matches(/F.*/g), }); 方法2 通过test方法匹配 const yup = require('yup'); let personSchema = yup.object({ name: yup.string().min(4), gender: yup.string(), id: yup.string().test('id', value =\u003e { return value.startsWith('F'); }) }); console.log(personSchema.isValidSync({ name: 'Lucy', gender: 'F', id: 'F123', })); console.log(personSchema.isValidSync({ name: 'Lucy', gender: 'F', id: 'M123', })); ","date":"2021-10-22","objectID":"/2021/10/22/20211022_yup/:3:2","tags":["npm源码剖析","yup","schema","validator"],"title":"npm源码剖析系列-Schema校验神器之Yup","uri":"/2021/10/22/20211022_yup/"},{"categories":["npm源码剖析"],"content":"异步判断 需要注意的，test方法传入的方法，支持异步的Async方法，在特殊情况下可以使用。比如以下代码 const yup = require('yup'); let personSchema = yup.object({ name: yup.string().min(4), gender: yup.string(), id: yup.string().test('id', async value =\u003e { return new Promise((resolve, reject) =\u003e { setTimeout(() =\u003e { if (value.startsWith('F')) { resolve(); } else { reject(); } }, 1000) }) }) }); personSchema.isValid({ name: 'Lucy', gender: 'F', id: 'F123', }).then(result =\u003e { console.log(result); }) personSchema.isValid({ name: 'Lucy', gender: 'F', id: 'M123', }).then(result =\u003e { console.log(result); }) ","date":"2021-10-22","objectID":"/2021/10/22/20211022_yup/:3:3","tags":["npm源码剖析","yup","schema","validator"],"title":"npm源码剖析系列-Schema校验神器之Yup","uri":"/2021/10/22/20211022_yup/"},{"categories":["npm源码剖析"],"content":"判断其中子元素 let schema = object({ foo: array().of( object({ loose: boolean(), bar: string().when('loose', { is: true, otherwise: (s) =\u003e s.strict(), }), }), ), }); let rootValue = { foo: [{ bar: 1 }, { bar: 1, loose: true }], }; await schema.validateAt('foo[0].bar', rootValue); // =\u003e ValidationError: must be a string await schema.validateAt('foo[1].bar', rootValue); // =\u003e '1' ","date":"2021-10-22","objectID":"/2021/10/22/20211022_yup/:3:4","tags":["npm源码剖析","yup","schema","validator"],"title":"npm源码剖析系列-Schema校验神器之Yup","uri":"/2021/10/22/20211022_yup/"},{"categories":["npm源码剖析"],"content":"输出详细的错误信息 import { setLocale } from 'yup'; setLocale({ // use constant translation keys for messages without values mixed: { default: 'field_invalid', }, // use functions to generate an error object that includes the value from the schema number: { min: ({ min }) =\u003e ({ key: 'field_too_short', values: { min } }), max: ({ max }) =\u003e ({ key: 'field_too_big', values: { max } }), }, }); // now use Yup schemas AFTER you defined your custom dictionary let schema = yup.object().shape({ name: yup.string(), age: yup.number().min(18), }); schema.validate({ name: 'jimmy', age: 11 }).catch(function (err) { err.name; // =\u003e 'ValidationError' err.errors; // =\u003e [{ key: 'field_too_short', values: { min: 18 } }] }); ","date":"2021-10-22","objectID":"/2021/10/22/20211022_yup/:3:5","tags":["npm源码剖析","yup","schema","validator"],"title":"npm源码剖析系列-Schema校验神器之Yup","uri":"/2021/10/22/20211022_yup/"},{"categories":["npm源码剖析"],"content":"What’s more Yup在设计的时候，还包括了很多增强的功能，最典型的比如cast数据转换等等。但是实际上在使用的时候，我们更聚焦在数据的校验，如果校验之后不合法，需要转化，需要处理，一般会有其他的业务逻辑负责。 把上面的原理大体读懂，常用的例子搞明白，就能掌握Yup。 ","date":"2021-10-22","objectID":"/2021/10/22/20211022_yup/:4:0","tags":["npm源码剖析","yup","schema","validator"],"title":"npm源码剖析系列-Schema校验神器之Yup","uri":"/2021/10/22/20211022_yup/"},{"categories":["npm源码剖析"],"content":"这UUID到底是什么？npm分享之uuid, 协议的本身有很多个版本，比如v1，v2，v3，v4，v5。版本不同是因为其使用的工况可能不同","date":"2021-10-19","objectID":"/2021/10/19/20211019_uuid/","tags":["npm源码剖析","UUID","UUIDv4"],"title":"npm源码剖析系列-UUID到底是什么?","uri":"/2021/10/19/20211019_uuid/"},{"categories":["npm源码剖析"],"content":"npm仓库信息 npm: https://www.npmjs.com/package/uuid downloads: 460w git: github.com/uuidjs/uuid#readme repo: 12k ","date":"2021-10-19","objectID":"/2021/10/19/20211019_uuid/:1:0","tags":["npm源码剖析","UUID","UUIDv4"],"title":"npm源码剖析系列-UUID到底是什么?","uri":"/2021/10/19/20211019_uuid/"},{"categories":["npm源码剖析"],"content":"UUID分析 UUID(Universally unique identifier)，统一资源定位符，可以用来标识唯一的资源。典型的UUID长这个样子。 123e4567-e89b-12d3-a456-426614174000 xxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx 你可能经常使用，但是大概率很难讲个所以然。实际上，目前我们使用的UUID，主要遵循RFC4122版本，协议的链接在 https://www.ietf.org/rfc/rfc4122.txt 。协议的本身有很多个版本，比如v1，v2，v3，v4，v5。版本不同是因为其使用的工况可能不同，官方的定义如下: Msb0 Msb1 Msb2 Msb3 Version Description 0 0 0 1 1 The time-based version specified in this document. 0 0 1 0 2 DCE Security version, with embedded POSIX UIDs. 0 0 1 1 3 The name-based version specified in this document that uses MD5 hashing. 0 1 0 0 4 The randomly or pseudo- randomly generated version specified in this document. 0 1 0 1 5 The name-based version specified in this document that uses SHA-1 hashing. 版本多的让人眼花缭乱，那么实际上在使用的时候改用哪种呢？参考StackOverflow的高票答案，可以按照这个方法选择 仅需要一个UUID: 可以使用version1 和 version4 version1: 基于网卡mac地址+时间戳构建。 version4: 完全基于随机数/伪随机数构建。 UUID需要基于一定的参数可重建(reproducible)，需要version3或者version5 version3: 基于namespace+name → MD5 version5: 基于namespace+name → SHA-1 基于以上的原则，就可以容易的选择版本。其中有个细节可以注意的是，由于v4版本完全基于时间戳构建，所以理论上可能存在UUID碰撞的可能。但是实际在使用中不用太在意，有两个原因: 1. 碰撞的几率天生就很小; 2. 碰撞几率计算也是根据所有场景放在一起，但是每个应用都有自己的场景，uuid也不会通用，因此实际上不用担心。 当然，如果只是使用uuidv4的话，可以使用这个代码片段 (https://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid) function uuidv4() { return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =\u003e (c ^ crypto.getRandomValues(new Uint8Array(1))[0] \u0026 15 \u003e\u003e c / 4).toString(16) ); } console.log(uuidv4()); ","date":"2021-10-19","objectID":"/2021/10/19/20211019_uuid/:2:0","tags":["npm源码剖析","UUID","UUIDv4"],"title":"npm源码剖析系列-UUID到底是什么?","uri":"/2021/10/19/20211019_uuid/"},{"categories":["npm源码剖析"],"content":"使用 import { v1 as uuidv1 } from 'uuid'; uuidv1(); // ⇨ '2c5ea4c0-4067-11e9-8bad-9b1deb4d3b7d' 使用起来比较简单，不在赘述。 ","date":"2021-10-19","objectID":"/2021/10/19/20211019_uuid/:3:0","tags":["npm源码剖析","UUID","UUIDv4"],"title":"npm源码剖析系列-UUID到底是什么?","uri":"/2021/10/19/20211019_uuid/"},{"categories":["npm源码剖析"],"content":"What’more 无三方库。 ","date":"2021-10-19","objectID":"/2021/10/19/20211019_uuid/:4:0","tags":["npm源码剖析","UUID","UUIDv4"],"title":"npm源码剖析系列-UUID到底是什么?","uri":"/2021/10/19/20211019_uuid/"},{"categories":["npm源码剖析"],"content":"querystring是URL的参数传递方式。https://example.com/path/to/page?name=ferret\u0026color=purple 就是他的数据格式, 但是如果要问问你querystring到底来自哪个标准？具体的处理方式你真的懂吗？可能大部分人都要摇头。这篇文章就能帮到你。","date":"2021-10-19","objectID":"/2021/10/19/20211018_querystring/","tags":["npm源码剖析","querystring"],"title":"npm源码剖析系列-URL的参数你真的懂吗？querystring","uri":"/2021/10/19/20211018_querystring/"},{"categories":["npm源码剖析"],"content":"URL的参数你真的懂吗？-querystring https://example.com/path/to/page?name=ferret\u0026color=purple 大家都熟悉，querystring是URL的参数传递方式。上面就是他的数据格式。 但是如果要问问你querystring到底来自哪个标准？具体的处理方式你真的懂吗？可能大部分人都要摇头。这篇文章就能帮到你。 ","date":"2021-10-19","objectID":"/2021/10/19/20211018_querystring/:0:0","tags":["npm源码剖析","querystring"],"title":"npm源码剖析系列-URL的参数你真的懂吗？querystring","uri":"/2021/10/19/20211018_querystring/"},{"categories":["npm源码剖析"],"content":"背景 querystring主要来自URL标准，URL全称为Uniform Resource Locators，统一资源定位符。Web是其最常见的使用场景，除此之外，ftp、ssh等协议也是基于这些标准来使用的，举个例子。 # Web URL https://example.com/path/to/page?name=ferret\u0026color=purple # Ftp URL ftp://test:test@192.168.0.1:21/profile URL是一个标准，主要有两个版本: rfc1738: https://datatracker.ietf.org/doc/html/rfc1738 rfc3986: https://datatracker.ietf.org/doc/html/rfc3986 querystring就来自这个URL标准，querystring主要处理两部分: 数据传输格式: paramA=valueA\u0026paramB=valueB 数据的编码解码: 1)预留字符 # : 2) 特殊字符转码 SPACE -\u003e 0x20 qs库呢，就是这两部分逻辑的具体实现。那么刚刚提到了rfc1738和rfc3986，在querystring方便主要是对 SPACE %20 的处理方式不同，rfc1738 %20-\u003e +, rfc3986保留 %20 数据传输格式 field1=value1\u0026field2=value2\u0026field3=value3... 当然可能有的场景也会传输一些特殊的字符，比如JSON、数组等等，但是一般大家在使用过程中，都会先encode，变成普通的字符串；解码的时候再进行反向操作。 数据的编码解码 我们不去读常常的RFC标准了，在Wiki上可以找到如下的编解码定义: Characters that cannot be converted to the correct charset are replaced with HTML numeric character references[11] SPACE is encoded as ‘+’ or ‘%20’ Letters (A–Z and a–z), numbers (0–9) and the characters ‘~’,'-','.' and ‘_’ are left as-is is encoded by %2B All other characters are encoded as a %HH hexadecimal representation with any non-ASCII characters first encoded as UTF-8 (or other specified encoding) 用大白话呢就是下面这个，注意步骤2中关于SPACE空格的处理，就是两个不同协议的区别。 如果某个字符编码不能转成对应的字符，那么就使用数字的替代表示(数学字符等) 空白SPACE，转成 + 或者 %20 ( + 的ASCII编码为 0x20) A-z a-z 0-9 ~ - . _ 这些字符保留 转为 %2B 其他剩余字符，转为%HH的十六进制表示 ","date":"2021-10-19","objectID":"/2021/10/19/20211018_querystring/:1:0","tags":["npm源码剖析","querystring"],"title":"npm源码剖析系列-URL的参数你真的懂吗？querystring","uri":"/2021/10/19/20211018_querystring/"},{"categories":["npm源码剖析"],"content":"qs 回到qs这个依赖库，就是对上述操作进行了封装。当然qs本身在对象数据的传输、解析(深度控制等)、数组等做了很多工作，但是实际上用的都比较少。 使用 举个官方的例子 var qs = require('qs'); var assert = require('assert'); var obj = qs.parse('a=c'); assert.deepEqual(obj, { a: 'c' }); var str = qs.stringify(obj); assert.equal(str, 'a=c'); What’s More 在面向IE等老破浏览器编程的时候，其实这种库是特别有价值的，但是现代浏览器和Node都提供了相似的内置API，可以直接使用 Web: https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams Node: https://nodejs.org/api/url.html#url_class_urlsearchparams ","date":"2021-10-19","objectID":"/2021/10/19/20211018_querystring/:1:1","tags":["npm源码剖析","querystring"],"title":"npm源码剖析系列-URL的参数你真的懂吗？querystring","uri":"/2021/10/19/20211018_querystring/"},{"categories":["npm源码剖析"],"content":"q取不到应该有的值，是开发中常见的情况，大部分语言都有这个问题，C语言会变成野指针；Java会有NullPointerException；同样的在JavaScript中就是undefined。在和其他三方库或者服务端交互的时候，这种情况经常出现。一旦出现，就很糟心，会阻塞代码执行；会抛出异常；甚至会引起白屏等渲染异常。那么怎么避免，怎么优雅的避免出现这些问题呢？这篇文章就能帮到你。","date":"2021-10-18","objectID":"/2021/10/18/20211018_npm_idx_lodash/","tags":["npm源码剖析","防御式编程","lodash","lodash.get","idx"],"title":"npm源码剖析系列-防御式编程利器: lodash.get 和 idx","uri":"/2021/10/18/20211018_npm_idx_lodash/"},{"categories":["npm源码剖析"],"content":"今天和大家聊聊两个常用的库 lodash.get https://www.npmjs.com/package/lodash.get Idx https://www.npmjs.com/package/idx ","date":"2021-10-18","objectID":"/2021/10/18/20211018_npm_idx_lodash/:0:0","tags":["npm源码剖析","防御式编程","lodash","lodash.get","idx"],"title":"npm源码剖析系列-防御式编程利器: lodash.get 和 idx","uri":"/2021/10/18/20211018_npm_idx_lodash/"},{"categories":["npm源码剖析"],"content":"Can not read property of undefined 取不到应该有的值，是开发中常见的情况，大部分语言都有这个问题，C语言会变成野指针；Java会有NullPointerException；同样的在JavaScript中就是undefined。在和其他三方库或者服务端交互的时候，这种情况经常出现。一旦出现，就很糟心，会阻塞代码执行；会抛出异常；甚至会引起白屏等渲染异常。 图片 为了避免我们的代码挂掉，我们常常会采用防御式编程。当然这是文绉绉的说法，简单来说，就是一路判断下去，比如: variables \u0026\u0026 variable.propertyA \u0026\u0026 variable.propertyA.propertyB. 数据结构简单的情况下，这样写挺好；可是如果层数特别多，又或是有数组，情况就变得难受起来，举个例子: variables \u0026\u0026 variable.propertyA \u0026\u0026 variable.propertyA.propertyB \u0026\u0026 variable.propertyA.propertyB[0] \u0026\u0026 variable.propertyA.propertyB[0].propertyC ","date":"2021-10-18","objectID":"/2021/10/18/20211018_npm_idx_lodash/:1:0","tags":["npm源码剖析","防御式编程","lodash","lodash.get","idx"],"title":"npm源码剖析系列-防御式编程利器: lodash.get 和 idx","uri":"/2021/10/18/20211018_npm_idx_lodash/"},{"categories":["npm源码剖析"],"content":"怎么省事？ lodash.get和idx这两个库都可以帮我们面对这种情况，先看lodash.get. lodash.get实际上是lodash工具库的一个子集。这是一些官方的例子。 var object = { 'a': [{ 'b': { 'c': 3 } }] }; _.get(object, 'a[0].b.c'); // =\u003e 3 _.get(object, ['a', '0', 'b', 'c']); // =\u003e 3 _.get(object, 'a.b.c', 'default'); // =\u003e 'default' _.get(object, path, [defaultValue]) 有3个变量， 为被索引的对象object 为访问属性的路径path 为默认数值defaultValue。 其中关键的参数为path。举个例子，如果path为a[0].b.c，则表示a为数组，a的第一个元素，并进一步获取该其下的属性b，属性b下的属性c。那么我们把前面的例子用lodash.get重新写一遍，怎么写呢？ // pure javascript variables \u0026\u0026 variable.propertyA \u0026\u0026 variable.propertyA.propertyB \u0026\u0026 variable.propertyA.propertyB[0] \u0026\u0026 variable.propertyA.propertyB[0].propertyC // lodash.get _.get(variables, ‘propertyA.propertyB[0].propertyC’) 简单明了。同样的，idx的作用是一样。 // idx idx(variables, _ =\u003e _.propertyA.propertyB[0].propertyC) 哪个更好呢？从下载量上看，lodash.get的使用人数会更多，但是两者功能是同样的，性能也没大差别，看个人的喜好即可。 ","date":"2021-10-18","objectID":"/2021/10/18/20211018_npm_idx_lodash/:2:0","tags":["npm源码剖析","防御式编程","lodash","lodash.get","idx"],"title":"npm源码剖析系列-防御式编程利器: lodash.get 和 idx","uri":"/2021/10/18/20211018_npm_idx_lodash/"}]